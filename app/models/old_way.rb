# == Schema Information
#
# Table name: ways
#
#  way_id       :integer          default(0), not null, primary key
#  changeset_id :integer          not null
#  timestamp    :datetime         not null
#  version      :integer          not null, primary key
#  visible      :boolean          default(TRUE), not null
#  redaction_id :integer
#
# Indexes
#
#  ways_changeset_id_idx  (changeset_id)
#  ways_timestamp_idx     (timestamp)
#
# Foreign Keys
#
#  ways_changeset_id_fkey  (changeset_id => changesets.id)
#  ways_redaction_id_fkey  (redaction_id => redactions.id)
#

class OldWay < ActiveRecord::Base
  include ConsistencyValidations
  include ObjectMetadata

  self.table_name = "ways"
  self.primary_keys = "way_id", "version"

  # note this needs to be included after the table name changes, or
  # the queries generated by Redactable will use the wrong table name.
  include Redactable

  belongs_to :changeset
  belongs_to :redaction
  belongs_to :current_way, :class_name => "Way", :foreign_key => "way_id"

  has_many :old_nodes, :class_name => "OldWayNode", :foreign_key => [:way_id, :version]
  has_many :old_tags, :class_name => "OldWayTag", :foreign_key => [:way_id, :version]

  validates :changeset, :presence => true, :associated => true
  validates :timestamp, :presence => true
  validates :visible, :inclusion => [true, false]

  def self.from_way(way)
    old_way = OldWay.new
    old_way.visible = way.visible
    old_way.changeset_id = way.changeset_id
    old_way.timestamp = way.timestamp
    old_way.way_id = way.id
    old_way.version = way.version
    old_way.nds = way.nds
    old_way.tags = way.tags
    old_way
  end

  def save_with_dependencies!
    save!

    tags.each do |k, v|
      tag = OldWayTag.new
      tag.k = k
      tag.v = v
      tag.way_id = way_id
      tag.version = version
      tag.save!
    end

    sequence = 1
    nds.each do |n|
      nd = OldWayNode.new
      nd.id = [way_id, version, sequence]
      nd.node_id = n
      nd.save!
      sequence += 1
    end
  end

  def nds
    @nds ||= old_nodes.order(:sequence_id).collect(&:node_id)
  end

  def tags
    @tags ||= Hash[old_tags.collect { |t| [t.k, t.v] }]
  end

  attr_writer :nds

  attr_writer :tags

  def to_xml_node(changeset_cache = {}, user_display_name_cache = {})
    el = XML::Node.new "way"
    el["id"] = way_id.to_s

    add_metadata_to_xml_node(el, self, changeset_cache, user_display_name_cache)

    old_nodes.each do |nd| # FIXME: need to make sure they come back in the right order
      node_el = XML::Node.new "nd"
      node_el["ref"] = nd.node_id.to_s
      el << node_el
    end

    add_tags_to_xml_node(el, old_tags)

    el
  end

  # Read full version of old way
  # For get_nodes_undelete, uses same nodes, even if they've moved since
  # For get_nodes_revert,   allocates new ids
  # Currently returns Potlatch-style array
  # where [5] indicates whether latest version is usable as is (boolean)
  # (i.e. is it visible? are we actually reverting to an earlier version?)

  def get_nodes_undelete
    nds.collect do |n|
      node = Node.find(n)
      [node.lon, node.lat, n, node.version, node.tags_as_hash, node.visible]
    end
  end

  def get_nodes_revert(timestamp)
    points = []
    nds.each do |n|
      oldnode = OldNode.where("node_id = ? AND timestamp <= ?", n, timestamp).unredacted.order("timestamp DESC").first
      curnode = Node.find(n)
      id = n
      reuse = curnode.visible
      if oldnode.lat != curnode.lat || oldnode.lon != curnode.lon || oldnode.tags != curnode.tags
        # node has changed: if it's in other ways, give it a new id
        if curnode.ways - [way_id]
          id = -1
          reuse = false
        end
      end
      points << [oldnode.lon, oldnode.lat, id, curnode.version, oldnode.tags_as_hash, reuse]
    end
    points
  end

  # Temporary method to match interface to ways
  def way_nodes
    old_nodes
  end

  # Pretend we're not in any relations
  def containing_relation_members
    []
  end

  # check whether this element is the latest version - that is,
  # has the same version as its "current" counterpart.
  def is_latest_version?
    current_way.version == version
  end
end
