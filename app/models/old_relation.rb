# == Schema Information
#
# Table name: relations
#
#  relation_id  :bigint(8)        default(0), not null, primary key
#  changeset_id :bigint(8)        not null
#  timestamp    :datetime         not null
#  version      :bigint(8)        not null, primary key
#  visible      :boolean          default(TRUE), not null
#  redaction_id :integer
#
# Indexes
#
#  relations_changeset_id_idx  (changeset_id)
#  relations_timestamp_idx     (timestamp)
#
# Foreign Keys
#
#  relations_changeset_id_fkey  (changeset_id => changesets.id)
#  relations_redaction_id_fkey  (redaction_id => redactions.id)
#

class OldRelation < ApplicationRecord
  include ConsistencyValidations
  include ObjectMetadata

  self.table_name = "relations"
  self.primary_keys = "relation_id", "version"

  # note this needs to be included after the table name changes, or
  # the queries generated by Redactable will use the wrong table name.
  include Redactable

  belongs_to :changeset
  belongs_to :redaction
  belongs_to :current_relation, :class_name => "Relation", :foreign_key => "relation_id"

  has_many :old_members, -> { order(:sequence_id) }, :class_name => "OldRelationMember", :foreign_key => [:relation_id, :version]
  has_many :old_tags, :class_name => "OldRelationTag", :foreign_key => [:relation_id, :version]

  validates :changeset, :presence => true, :associated => true
  validates :timestamp, :presence => true
  validates :visible, :inclusion => [true, false]

  def self.from_relation(relation)
    old_relation = OldRelation.new
    old_relation.visible = relation.visible
    old_relation.changeset_id = relation.changeset_id
    old_relation.timestamp = relation.timestamp
    old_relation.relation_id = relation.id
    old_relation.version = relation.version
    old_relation.members = relation.members
    old_relation.tags = relation.tags
    old_relation
  end

  def save_with_dependencies!
    save!

    tags.each do |k, v|
      tag = OldRelationTag.new
      tag.k = k
      tag.v = v
      tag.relation_id = relation_id
      tag.version = version
      tag.save!
    end

    members.each_with_index do |m, i|
      member = OldRelationMember.new
      member.id = [relation_id, version, i]
      member.member_type = m[0].classify
      member.member_id = m[1]
      member.member_role = m[2]
      member.save!
    end
  end

  def members
    @members ||= old_members.collect do |member|
      [member.member_type, member.member_id, member.member_role]
    end
  end

  def tags
    @tags ||= Hash[old_tags.collect { |t| [t.k, t.v] }]
  end

  attr_writer :members

  attr_writer :tags

  def to_xml
    doc = OSM::API.new.get_xml_doc
    doc.root << to_xml_node
    doc
  end

  def to_xml_node(changeset_cache = {}, user_display_name_cache = {})
    el = XML::Node.new "relation"
    el["id"] = relation_id.to_s

    add_metadata_to_xml_node(el, self, changeset_cache, user_display_name_cache)

    old_members.each do |member|
      member_el = XML::Node.new "member"
      member_el["type"] = member.member_type.to_s.downcase
      member_el["ref"] = member.member_id.to_s # "id" is considered uncool here as it should be unique in XML
      member_el["role"] = member.member_role.to_s
      el << member_el
    end

    add_tags_to_xml_node(el, old_tags)

    el
  end

  # Temporary method to match interface to relations
  def relation_members
    old_members
  end

  # Pretend we're not in any relations
  def containing_relation_members
    []
  end

  # check whether this element is the latest version - that is,
  # has the same version as its "current" counterpart.
  def is_latest_version?
    current_relation.version == version
  end
end
