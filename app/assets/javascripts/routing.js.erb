/*
	osm.org routing interface
	
	See also:
	https://github.com/apmon/openstreetmap-website/tree/routing2
	https://github.com/apmon/openstreetmap-website/compare/routing2
	https://github.com/apmon/openstreetmap-website/blob/9755c3ae0a8d0684d43760f91dc864ff42d8477a/app/views/routing/start.js.erb

	*** translation (including all alerts and presentation)
	*** export GPX
	*** URL history (or do we consciously not want to support that?)
	*** spinner when waiting for result (beneath 'Go' button?)

	*** add YOURS engine
*/

var TURN_INSTRUCTIONS=[]

var ROUTING_POLYLINE={
	color: '#03f',
	opacity: 0.3,
	weight: 10
};


OSM.RoutingEngines={
	list: []
	// common functions and constants, e.g. OSRM parser, can go here
};

OSM.Routing=function(map,name,jqSearch) {
	var r={};

    TURN_INSTRUCTIONS=["",
	I18n.t('javascripts.directions.instructions.continue_on'),				// 1
	I18n.t('javascripts.directions.instructions.slight_right'),		// 2
	I18n.t('javascripts.directions.instructions.turn_right'),			// 3
	I18n.t('javascripts.directions.instructions.sharp_right'),		// 4
	I18n.t('javascripts.directions.instructions.uturn'),			// 5
	I18n.t('javascripts.directions.instructions.sharp_left'),			// 6
	I18n.t('javascripts.directions.instructions.turn_left'),			// 7
	I18n.t('javascripts.directions.instructions.slight_left'),		// 8
	I18n.t('javascripts.directions.instructions.via_point'),				// 9
	I18n.t('javascripts.directions.instructions.follow'),					// 10
	I18n.t('javascripts.directions.instructions.roundabout'),		// 11
	I18n.t('javascripts.directions.instructions.leave_roundabout'),		// 12
	I18n.t('javascripts.directions.instructions.stay_roundabout'),	// 13
	I18n.t('javascripts.directions.instructions.start'),			// 14
	I18n.t('javascripts.directions.instructions.destination'),		// 15
	I18n.t('javascripts.directions.instructions.against_oneway'),	// 16
	I18n.t('javascripts.directions.instructions.end_oneway')]		// 17

	r.map=map;				// Leaflet map
	r.name=name;			// global variable name of this instance (needed for JSONP)
	r.jqSearch=jqSearch;	// JQuery object for search panel

	r.route_from=null;		// null=unset, false=awaiting response, [lat,lon]=geocoded
	r.route_to=null;		//  |
	r.awaitingGeocode=false;// true if the user has requested a route, but we're waiting on a geocode result
	r.awaitingRoute=false;	// true if we've asked the engine for a route and are waiting to hear back
	r.viaPoints=[];			// not yet used

	r.polyline=null;		// Leaflet polyline object
	r.popup=null;			// Leaflet popup object
	r.marker_from=null;		// Leaflet from marker
	r.marker_to=null;		// Leaflet to marker

	r.chosenEngine=null;	// currently selected routing engine

	var icon_from = L.icon({
		iconUrl: <%= asset_path('marker-green.png').to_json %>,
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
		shadowSize: [41, 41]
	});
	var icon_to = L.icon({
		iconUrl: <%= asset_path('marker-red.png').to_json %>,
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
		shadowSize: [41, 41]
	});

	// Geocoding

	r.geocode=function(id,event) { var _this=this;
		var field=event.target;
		var v=event.target.value;
		// *** do something if v==''
		var querystring = '<%= NOMINATIM_URL %>search?q=' + encodeURIComponent(v) + '&format=json';
		// *** &accept-language=<%#= request.user_preferred_languages.join(',') %>
		// *** prefer current viewport
		r[field.id]=false;
		$.getJSON(querystring, function(json) { _this._gotGeocode(json,field); });
	};
	
	r._gotGeocode=function(json,field) {
		if (json.length==0) {
			alert("Sorry, couldn't find that place."); 	// *** internationalise
			r[field.id]=null;
			return;
		}
		field.value=json[0].display_name;
		var lat=Number(json[0].lat), lon=Number(json[0].lon);
		r[field.id]=[lat,lon];
		r.updateMarker(field.id);
		if (r.awaitingGeocode) {
			r.awaitingGeocode=false;
			r.requestRoute(true);
		}
	};

	// Drag and drop markers
	
	r.handleDrop=function(e) {
		var id=e.originalEvent.dataTransfer.getData('id');
		var ll=r.map.mouseEventToLatLng(e.originalEvent);
		// *** ^^^ this is slightly off - we need to work out the latLng of the tip
		r.createMarker(ll,id);
		r.setNumericInput(ll,id);
		r.requestRoute(true);
		// update to/from field
	};
	r.createMarker=function(latlng,id) {
		if (r[id]) r.map.removeLayer(r[id]);
		r[id]=L.marker(latlng, {
			icon: id=='marker_from' ? icon_from : icon_to,
			draggable: true,
			name: id
		}).addTo(r.map);
		r[id].on('drag',r.markerDragged);
		r[id].on('dragend',r.markerDragged);
	};
	// Update marker from geocoded route input
	r.updateMarker=function(id) {
		var m=id.replace('route','marker');
		if (!r[m]) { r.createMarker(r[id],m); return; }
		var ll=r[m].getLatLng();
		if (ll.lat!=r[id][0] || ll.lng!=r[id][1]) {
			r.createMarker(r[id],m);
		}
	};
	// Marker has been dragged
	r.markerDragged=function(e) {
		if (e.type=='drag' && !r.chosenEngine.draggable) return;
		if (e.type=='drag' && r.awaitingRoute) return;
		r.setNumericInput(e.target.getLatLng(), e.target.options.name);
		r.requestRoute(e.type=='dragend');
	};
	// Set a route input field to a numeric value
	r.setNumericInput=function(ll,id) {
		var routeid=id.replace('marker','route');
		r[routeid]=[ll.lat,ll.lng];
		$("[name="+routeid+"]:visible").val(Math.round(ll.lat*10000)/10000+" "+Math.round(ll.lng*10000)/10000);
	}
	
	// Route-fetching UI

	r.requestRoute=function(isFinal) {
		if (r.route_from && r.route_to) {
			r.awaitingRoute=true;
			r.chosenEngine.getRoute(isFinal,[r.route_from,r.route_to]);
			// then, when the route has been fetched, it'll call the engine's gotRoute function
		} else if (r.route_from==false || r.route_to==false) {
			// we're waiting for a Nominatim response before we can request a route
			r.awaitingGeocode=true;
		}
	};

	// Take an array of Leaflet LatLngs and draw it as a polyline
	r.setPolyline=function(line) {
		if (r.polyline) map.removeLayer(r.polyline);
		r.polyline=L.polyline(line, ROUTING_POLYLINE).addTo(r.map);
		// r.map.fitBounds(r.polyline.getBounds());
		// *** ^^^ we only want to do this for geocode-originated routes
	};

	// Take directions and write them out
	// data = { steps: array of [latlng, sprite number, instruction text, distance in metres] }
	// sprite numbers equate to OSRM's route_instructions turn values
	// *** translations?
	r.setItinerary=function(data) {
		// Create base table
		$("#content").removeClass("overlay-sidebar");
		$('#sidebar_content').empty();
		var html="<table id='turnbyturn' />";
		$('#sidebar_content').html(html);
		// Add each row
		var cumulative=0;
		for (var i=0; i<data.steps.length; i++) {
			var step=data.steps[i];
			// Distance
			var dist=step[3];
			if (dist<5) { dist=""; }
			else if (dist<200) { dist=Math.round(dist/10)*10+"m"; }
			else if (dist<1500) { dist=Math.round(dist/100)*100+"m"; }
			else if (dist<5000) { dist=Math.round(dist/100)/10+"km"; }
			else { dist=Math.round(dist/1000)+"km"; }
			// Add to table
			var row=$("<tr class='turn'/>");
			row.append("<td class='direction i"+step[1]+"'> ");
			row.append("<td class='instruction'>"+step[2]);
			row.append("<td class='distance'>"+dist);
			with ({ num: i, ll: step[0] }) {
				row.on('click',function(e) { r.clickTurn(num, ll); });
			};
			$('#turnbyturn').append(row);
			cumulative+=step[3];
		}
		$('#sidebar_content').prepend('<h2><a class="geolink" href="#" onclick="$(~.close_directions~).click();return false;"><span class="icon close"></span></a>' + I18n.t('javascripts.directions.directions') + ' (' + (cumulative*0.001).toFixed(1) + ' km)' + '</h2>'.replace(/~/g,"'"));


	};
	r.clickTurn=function(num,latlng) {
		r.popup=L.popup().setLatLng(latlng).setContent("<p>"+(num+1)+"</p>").openOn(r.map);
	};

	// Close all routing UI
	
	r.close=function() {
		$("#content").addClass("overlay-sidebar");
		r.route_from=r.route_to=null;
		$(".query_wrapper.routing input").val("");
		var remove=['polyline','popup','marker_from','marker_to'];
		for (var i=0; i<remove.length; i++) {
			if (r[remove[i]]) { map.removeLayer(r[remove[i]]); r[remove[i]]=null; }
		}
	};

	// Routing engine handling

	// Add all engines
	var list=OSM.RoutingEngines.list;
	list.sort(function(a,b) { return a.name>b.name; });
	var select=r.jqSearch.find('select.routing_engines');
	for (var i=0; i<list.length; i++) {
		// Set up JSONP callback
		with ({num: i}) {
			list[num].requestJSONP=function(url) {
				var script = document.createElement('script');
				script.src = url+r.name+".gotRoute"+num;
				document.body.appendChild(script); 
			};
			r['gotRoute'+num]=function(data) { r.awaitingRoute=false; list[num].gotRoute(r,data); };
		}
		select.append("<option value='"+i+"'>"+I18n.t(list[i].name)+"</option>");
	}
	r.engines=list;
	r.chosenEngine=list[0];	// default to first engine

	// Choose an engine on dropdown change
	r.selectEngine=function(e) {
		r.chosenEngine=r.engines[e.target.selectedIndex];
	};
	// Choose an engine by name
	r.chooseEngine=function(name) {
		for (var i=0; i<r.engines.length; i++) {
			if (r.engines[i].name==name) {
				r.chosenEngine=r.engines[i];
				r.jqSearch.find('select.routing_engines').val(i);
			}
		}
	};

	return r;
};
