/*
    osm.org routing interface
*/

var TURN_INSTRUCTIONS=[]

var ROUTING_POLYLINE={
    color: '#03f',
    opacity: 0.3,
    weight: 10
};


OSM.RoutingEngines={
    list: []
};

OSM.Routing=function(map,name,jqSearch) {
    var r={};

    TURN_INSTRUCTIONS=["",
    I18n.t('javascripts.directions.instructions.continue_on'),      // 1
    I18n.t('javascripts.directions.instructions.slight_right'),     // 2
    I18n.t('javascripts.directions.instructions.turn_right'),       // 3
    I18n.t('javascripts.directions.instructions.sharp_right'),      // 4
    I18n.t('javascripts.directions.instructions.uturn'),            // 5
    I18n.t('javascripts.directions.instructions.sharp_left'),       // 6
    I18n.t('javascripts.directions.instructions.turn_left'),        // 7
    I18n.t('javascripts.directions.instructions.slight_left'),      // 8
    I18n.t('javascripts.directions.instructions.via_point'),        // 9
    I18n.t('javascripts.directions.instructions.follow'),           // 10
    I18n.t('javascripts.directions.instructions.roundabout'),       // 11
    I18n.t('javascripts.directions.instructions.leave_roundabout'), // 12
    I18n.t('javascripts.directions.instructions.stay_roundabout'),  // 13
    I18n.t('javascripts.directions.instructions.start'),            // 14
    I18n.t('javascripts.directions.instructions.destination'),      // 15
    I18n.t('javascripts.directions.instructions.against_oneway'),   // 16
    I18n.t('javascripts.directions.instructions.end_oneway')]       // 17

    r.map=map;              // Leaflet map
    r.name=name;            // global variable name of this instance (needed for JSONP)
    r.jqSearch=jqSearch;    // JQuery object for search panel

    r.route_from=null;      // null=unset, false=awaiting response, [lat,lon]=geocoded
    r.route_to=null;        //  |
    r.awaitingGeocode=false;// true if the user has requested a route, but we're waiting on a geocode result
    r.awaitingRoute=false;  // true if we've asked the engine for a route and are waiting to hear back
    r.dragging=false;       // true if the user is dragging a start/end point
    r.viaPoints=[];         // not yet used

    r.polyline=null;        // Leaflet polyline object
    r.popup=null;           // Leaflet popup object
    r.marker_from=null;     // Leaflet from marker
    r.marker_to=null;       // Leaflet to marker

    r.chosenEngine=null;    // currently selected routing engine

    var icon_from = L.icon({
        iconUrl: <%= asset_path('marker-green.png').to_json %>,
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
        shadowSize: [41, 41]
    });
    var icon_to = L.icon({
        iconUrl: <%= asset_path('marker-red.png').to_json %>,
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
        shadowSize: [41, 41]
    });

    // Geocoding

    r.geocode=function(id,event) { var _this=this;
        var field=event.target;
        var v=event.target.value;
        var querystring = '<%= NOMINATIM_URL %>search?q=' + encodeURIComponent(v) + '&format=json';
        // *** &accept-language=<%#= request.user_preferred_languages.join(',') %>
        r[field.id]=false;
        $.getJSON(querystring, function(json) { _this._gotGeocode(json,field); });
    };
    
    r._gotGeocode=function(json,field) {
        if (json.length==0) {
            alert(I18n.t('javascripts.directions.errors.no_place'));
            r[field.id]=null;
            return;
        }
        field.value=json[0].display_name;
        var lat=Number(json[0].lat), lon=Number(json[0].lon);
        r[field.id]=[lat,lon];
        r.updateMarker(field.id);
        if (r.awaitingGeocode) {
            r.awaitingGeocode=false;
            r.requestRoute(true, true);
        }
    };

    // Drag and drop markers
    
    r.handleDrop=function(e) {
        var oe=e.originalEvent;
        var id=oe.dataTransfer.getData('id');
        var pt=L.DomEvent.getMousePosition(oe,map.getContainer());  // co-ordinates of the mouse pointer at present
        pt.x+=Number(oe.dataTransfer.getData('offsetX'));
        pt.y+=Number(oe.dataTransfer.getData('offsetY'));
        var ll=map.containerPointToLatLng(pt);
        r.createMarker(ll,id);
        r.setNumericInput(ll,id);
        r.requestRoute(true, false);
        // update to/from field
    };
    r.createMarker=function(latlng,id) {
        if (r[id]) r.map.removeLayer(r[id]);
        r[id]=L.marker(latlng, {
            icon: id=='marker_from' ? icon_from : icon_to,
            draggable: true,
            name: id
        }).addTo(r.map);
        r[id].on('drag',r.markerDragged);
        r[id].on('dragend',r.markerDragged);
    };
    // Update marker from geocoded route input
    r.updateMarker=function(id) {
        var m=id.replace('route','marker');
        if (!r[m]) { r.createMarker(r[id],m); return; }
        var ll=r[m].getLatLng();
        if (ll.lat!=r[id][0] || ll.lng!=r[id][1]) {
            r.createMarker(r[id],m);
        }
    };
    // Marker has been dragged
    r.markerDragged=function(e) {
        r.dragging=(e.type=='drag');    // true for drag, false for dragend
        if (r.dragging && !r.chosenEngine.draggable) return;
        if (r.dragging && r.awaitingRoute) return;
        r.setNumericInput(e.target.getLatLng(), e.target.options.name);
        r.requestRoute(!r.dragging, false);
    };
    // Set a route input field to a numeric value
    r.setNumericInput=function(ll,id) {
        var routeid=id.replace('marker','route');
        r[routeid]=[ll.lat,ll.lng];
        $("[name="+routeid+"]:visible").val(Math.round(ll.lat*10000)/10000+" "+Math.round(ll.lng*10000)/10000);
    }
    
    // Route-fetching UI

    r.requestRoute=function(isFinal, updateZoom) {
        if (r.route_from && r.route_to) {
            $(".query_wrapper.routing .spinner").show();
            r.awaitingRoute=true;
            r.chosenEngine.getRoute(isFinal,[r.route_from,r.route_to]);
            if(updateZoom){
                r.map.fitBounds(L.latLngBounds([r.route_from, r.route_to]).pad(0.05));
            }
            // then, when the route has been fetched, it'll call the engine's gotRoute function
        } else if (r.route_from==false || r.route_to==false) {
            // we're waiting for a Nominatim response before we can request a route
            r.awaitingGeocode=true;
        }
    };

    // Take an array of Leaflet LatLngs and draw it as a polyline
    r.setPolyline=function(line) {
        if (r.polyline) map.removeLayer(r.polyline);
        r.polyline=L.polyline(line, ROUTING_POLYLINE).addTo(r.map);
    };

    // Take directions and write them out
    // data = { steps: array of [latlng, sprite number, instruction text, distance in metres] }
    // sprite numbers equate to OSRM's route_instructions turn values
    r.setItinerary=function(data) {
        // Create base table
        $("#content").removeClass("overlay-sidebar");
        $('#sidebar_content').empty();
        var html=('<h2><a class="geolink" href="#" onclick="$(~.close_directions~).click();return false;">' +
                  '<span class="icon close"></span></a>' + I18n.t('javascripts.directions.directions') + 
                  '</h2><p id="routing_summary">' + 
                  I18n.t('javascripts.directions.distance') + ': ' + r.formatDistance(data.distance)+ '. ' +
                  I18n.t('javascripts.directions.time'    ) + ': ' + r.formatTime(data.time) + '.</p>' +
                  '<table id="turnbyturn" />').replace(/~/g,"'");
        $('#sidebar_content').html(html);
        // Add each row
        var cumulative=0;
        for (var i=0; i<data.steps.length; i++) {
            var step=data.steps[i];
            // Distance
            var dist=step[3];
            if (dist<5) { dist=""; }
            else if (dist<200) { dist=Math.round(dist/10)*10+"m"; }
            else if (dist<1500) { dist=Math.round(dist/100)*100+"m"; }
            else if (dist<5000) { dist=Math.round(dist/100)/10+"km"; }
            else { dist=Math.round(dist/1000)+"km"; }
            // Add to table
            var row=$("<tr class='turn'/>");
            row.append("<td class='direction i"+step[1]+"'> ");
            row.append("<td class='instruction'>"+step[2]);
            row.append("<td class='distance'>"+dist);
            with ({ num: i, ll: step[0] }) {
                row.on('click',function(e) { r.clickTurn(num, ll); });
            };
            $('#turnbyturn').append(row);
            cumulative+=step[3];
        }
        $('#sidebar_content').append('<p id="routing_credit">' + r.chosenEngine.creditline + '</p>');

    };
    r.clickTurn=function(num,latlng) {
        r.popup=L.popup().setLatLng(latlng).setContent("<p>"+(num+1)+"</p>").openOn(r.map);
    };
    r.formatDistance=function(m) {
        if      (m < 1000 ) { return Math.round(m) + "m"; }
        else if (m < 10000) { return (m/1000.0).toFixed(1) + "km"; }
        else                { return Math.round(m / 1000)  + "km"; }
    };
    r.formatTime=function(s) {
        var d=new Date(s*1000); var h=d.getHours(); var m=d.getMinutes();
        return h+":"+(m<10 ? '0' : '')+m;
    };

    // Close all routing UI
    
    r.close=function() {
        $("#content").addClass("overlay-sidebar");
        r.route_from=r.route_to=null;
        $(".query_wrapper.routing input").val("");
        var remove=['polyline','popup','marker_from','marker_to'];
        for (var i=0; i<remove.length; i++) {
            if (r[remove[i]]) { map.removeLayer(r[remove[i]]); r[remove[i]]=null; }
        }
    };

    // Routing engine handling

    // Add all engines
    var list=OSM.RoutingEngines.list;
    list.sort(function(a,b) { return I18n.t(a.name)>I18n.t(b.name); });
    var select=r.jqSearch.find('select.routing_engines');
    for (var i=0; i<list.length; i++) {
        // Set up JSONP callback
        with ({num: i}) {
            list[num].requestJSONP=function(url) {
                var script = document.createElement('script');
                script.src = url+r.name+".gotRoute"+num;
                document.body.appendChild(script); 
            };
            list[num].requestCORS=function(url) {
                $.ajax({ url: url, method: "GET", data: {}, dataType: 'json', success: r['gotRoute'+num] });
            };
            r['gotRoute'+num]=function(data) { 
                r.awaitingRoute=false;
                $(".query_wrapper.routing .spinner").hide();
                if (!list[num].gotRoute(r,data)) {
                    // No route found
                    if (r.polyline) {
                        map.removeLayer(r.polyline);
                        r.polyline=null;
                    }
                    if (!r.dragging) { alert(I18n.t('javascripts.directions.errors.no_route')); }
                }
            };
        }
        select.append("<option value='"+i+"'>"+I18n.t(list[i].name)+"</option>");
    }
    r.engines=list;
    r.chosenEngine=list[0]; // default to first engine

    // Choose an engine on dropdown change
    r.selectEngine=function(e) {
        r.chosenEngine=r.engines[e.target.selectedIndex];
        if (r.polyline){ // and if a route is currently showing, must also refresh, else confusion
            r.requestRoute(true, false);
        }
    };
    // Choose an engine by name
    r.chooseEngine=function(name) {
        for (var i=0; i<r.engines.length; i++) {
            if (r.engines[i].name==name) {
                r.chosenEngine=r.engines[i];
                r.jqSearch.find('select.routing_engines').val(i);
            }
        }
    };

    return r;
};
