/*
	osm.org routing interface
	
	See also:
	https://github.com/apmon/openstreetmap-website/tree/routing2
	https://github.com/apmon/openstreetmap-website/compare/routing2
	https://github.com/apmon/openstreetmap-website/blob/9755c3ae0a8d0684d43760f91dc864ff42d8477a/app/views/routing/start.js.erb

	*** translation (including all alerts and presentation)
	*** export GPX
	*** URL history (or do we consciously not want to support that?)
	*** spinner when waiting for result (beneath 'Go' button?)

	*** add YOURS engine
*/

var TURN_INSTRUCTIONS=["",
	"Continue on ",				// 1
	"Slight right onto ",		// 2
	"Turn right onto ",			// 3
	"Sharp right onto ",		// 4
	"U-turn along ",			// 5
	"Sharp left onto ",			// 6
	"Turn left onto ",			// 7
	"Slight left onto ",		// 8
	"(via point) ",				// 9
	"Follow ",					// 10
	"At roundabout take ",		// 11
	"Leave roundabout - ",		// 12
	"Stay on roundabout - ",	// 13
	"Start at end of ",			// 14
	"Reach destination",		// 15
	"Go against one-way on ",	// 16
	"End of one-way on "]		// 17

var ROUTING_POLYLINE={
	color: '#03f',
	opacity: 0.3,
	weight: 10
};


OSM.RoutingEngines={
	list: []
	// common functions and constants, e.g. OSRM parser, can go here
};

OSM.Routing=function(map,name,jqSearch) {
	var r={};

	r.map=map;				// Leaflet map
	r.name=name;			// global variable name of this instance (needed for JSONP)
	r.jqSearch=jqSearch;	// JQuery object for search panel

	r.route_from=null;		// null=unset, false=awaiting response, [lat,lon]=geocoded
	r.route_to=null;		//  |
	r.awaitingGeocode=false;// true if the user has requested a route, but we're waiting on a geocode result
	r.awaitingRoute=false;	// true if we've asked the engine for a route and are waiting to hear back
	r.viaPoints=[];			// not yet used

	r.polyline=null;		// Leaflet polyline object
	r.popup=null;			// Leaflet popup object
	r.marker_from=null;		// Leaflet from marker
	r.marker_to=null;		// Leaflet to marker

	r.chosenEngine=null;	// currently selected routing engine

	var icon_from = L.icon({
		iconUrl: <%= asset_path('marker-green.png').to_json %>,
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
		shadowSize: [41, 41]
	});
	var icon_to = L.icon({
		iconUrl: <%= asset_path('marker-red.png').to_json %>,
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
		shadowSize: [41, 41]
	});

	// Geocoding

	r.geocode=function(id,event) { var _this=this;
		var field=event.target;
		var v=event.target.value;
		// *** do something if v==''
		var querystring = '<%= NOMINATIM_URL %>search?q=' + encodeURIComponent(v) + '&format=json';
		// *** &accept-language=<%#= request.user_preferred_languages.join(',') %>
		// *** prefer current viewport
		r[field.id]=false;
		$.getJSON(querystring, function(json) { _this._gotGeocode(json,field); });
	};
	
	r._gotGeocode=function(json,field) {
		if (json.length==0) {
			alert("Sorry, couldn't find that place."); 	// *** internationalise
			r[field.id]=null;
			return;
		}
		field.value=json[0].display_name;
		var lat=Number(json[0].lat), lon=Number(json[0].lon);
		r[field.id]=[lat,lon];
		r.updateMarker(field.id);
		if (r.awaitingGeocode) {
			r.awaitingGeocode=false;
			r.requestRoute(true);
		}
	};

	// Drag and drop markers
	
	r.handleDrop=function(e) {
		var id=e.originalEvent.dataTransfer.getData('id');
		var ll=r.map.mouseEventToLatLng(e.originalEvent);
		// *** ^^^ this is slightly off - we need to work out the latLng of the tip
		r.createMarker(ll,id);
		r.setNumericInput(ll,id);
		r.requestRoute(true);
		// update to/from field
	};
	r.createMarker=function(latlng,id) {
		if (r[id]) r.map.removeLayer(r[id]);
		r[id]=L.marker(latlng, {
			icon: id=='marker_from' ? icon_from : icon_to,
			draggable: true,
			name: id
		}).addTo(r.map);
		r[id].on('drag',r.markerDragged);
		r[id].on('dragend',r.markerDragged);
	};
	// Update marker from geocoded route input
	r.updateMarker=function(id) {
		var m=id.replace('route','marker');
		if (!r[m]) { r.createMarker(r[id],m); return; }
		var ll=r[m].getLatLng();
		if (ll.lat!=r[id][0] || ll.lng!=r[id][1]) {
			r.createMarker(r[id],m);
		}
	};
	// Marker has been dragged
	r.markerDragged=function(e) {
		if (e.type=='drag' && !r.chosenEngine.draggable) return;
		if (e.type=='drag' && r.awaitingRoute) return;
		r.setNumericInput(e.target.getLatLng(), e.target.options.name);
		r.requestRoute(e.type=='dragend');
	};
	// Set a route input field to a numeric value
	r.setNumericInput=function(ll,id) {
		var routeid=id.replace('marker','route');
		r[routeid]=[ll.lat,ll.lng];
		$("[name="+routeid+"]:visible").val(Math.round(ll.lat*10000)/10000+" "+Math.round(ll.lng*10000)/10000);
	}
	
	// Route-fetching UI

	r.requestRoute=function(isFinal) {
		if (r.route_from && r.route_to) {
			r.awaitingRoute=true;
			r.chosenEngine.getRoute(isFinal,[r.route_from,r.route_to]);
			// then, when the route has been fetched, it'll call the engine's gotRoute function
		} else if (r.route_from==false || r.route_to==false) {
			// we're waiting for a Nominatim response before we can request a route
			r.awaitingGeocode=true;
		}
	};

	// Take an array of Leaflet LatLngs and draw it as a polyline
	r.setPolyline=function(line) {
		if (r.polyline) map.removeLayer(r.polyline);
		r.polyline=L.polyline(line, ROUTING_POLYLINE).addTo(r.map);
		// r.map.fitBounds(r.polyline.getBounds());
		// *** ^^^ we only want to do this for geocode-originated routes
	};

	// Take directions and write them out
	// data = { steps: array of [latlng, sprite number, instruction text, distance in metres] }
	// sprite numbers equate to OSRM's route_instructions turn values
	// *** translations?
	r.setItinerary=function(data) {
		// Create base table
		$("#content").removeClass("overlay-sidebar");
		$('#sidebar_content').empty();
		var html='<h2><a class="geolink" href="#" onclick="$(~.close_directions~).click();return false;"><span class="icon close"></span></a>Directions</h2>'.replace(/~/g,"'");
		html+="<table id='turnbyturn' />";
		$('#sidebar_content').html(html);
		// Add each row
		var cumulative=0;
		for (var i=0; i<data.steps.length; i++) {
			var step=data.steps[i];
			// Distance
			var dist=step[3];
			if (dist<5) { dist=""; }
			else if (dist<200) { dist=Math.round(dist/10)*10+"m"; }
			else if (dist<1500) { dist=Math.round(dist/100)*100+"m"; }
			else if (dist<5000) { dist=Math.round(dist/100)/10+"km"; }
			else { dist=Math.round(dist/1000)+"km"; }
			// Add to table
			var row=$("<tr class='turn'/>");
			row.append("<td class='direction i"+step[1]+"'> ");
			row.append("<td class='instruction'>"+step[2]);
			row.append("<td class='distance'>"+dist);
			with ({ num: i, ll: step[0] }) {
				row.on('click',function(e) { r.clickTurn(num, ll); });
			};
			$('#turnbyturn').append(row);
			cumulative+=step[3];
		}
	};
	r.clickTurn=function(num,latlng) {
		r.popup=L.popup().setLatLng(latlng).setContent("<p>"+(num+1)+"</p>").openOn(r.map);
	};

	// Close all routing UI
	
	r.close=function() {
		$("#content").addClass("overlay-sidebar");
		var remove=[r.polyline,r.popup,r.marker_from,r.marker_to];
		for (var i=0; i<remove.length; i++) {
			if (remove[i]) map.removeLayer(remove[i]);
		}
	};

	// Routing engine handling

	// Add all engines
	var list=OSM.RoutingEngines.list;
	list.sort(function(a,b) { return a.name>b.name; });
	var select=r.jqSearch.find('select.routing_engines');
	for (var i=0; i<list.length; i++) {
		// Set up JSONP callback
		with ({num: i}) {
			list[num].requestJSONP=function(url) {
				var script = document.createElement('script');
				script.src = url+r.name+".gotRoute"+num;
				document.body.appendChild(script); 
			};
			r['gotRoute'+num]=function(data) { r.awaitingRoute=false; list[num].gotRoute(r,data); };
		}
		select.append("<option value='"+i+"'>"+list[i].name+"</option>");
	}
	r.engines=list;
	r.chosenEngine=list[0];	// default to first engine

	// Choose an engine on dropdown change
	r.selectEngine=function(e) {
		r.chosenEngine=r.engines[e.target.selectedIndex];
	};
	// Choose an engine by name
	r.chooseEngine=function(name) {
		for (var i=0; i<r.engines.length; i++) {
			if (r.engines[i].name==name) {
				r.chosenEngine=r.engines[i];
				r.jqSearch.find('select.routing_engines').val(i);
			}
		}
	};

	return r;
};
